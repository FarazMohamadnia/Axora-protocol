{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-9f13b412e357bbbfdb11918d632a43adb94c2fb1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Staking/staking.sol": "project/contracts/Staking/staking.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Staking/staking.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title StakingContract - Token Staking with Rewards\n * @dev A secure staking contract that allows users to stake tokens and earn rewards\n */\ncontract StakingContract is ReentrancyGuard, Pausable, Ownable {\n    // ============ STATE VARIABLES ============\n    \n    IERC20 public immutable stakingToken;        // The token being staked\n    IERC20 public immutable rewardToken;         // The token used for rewards\n    \n    uint256 public totalStaked;                  // Total amount of tokens staked\n    uint256 public totalRewardsDistributed;     // Total rewards distributed\n    \n    // Staking pool configuration\n    uint256 public constant MIN_STAKE_AMOUNT = 100 * 10**18;  // Minimum 100 tokens\n    uint256 public constant MAX_STAKE_AMOUNT = 1000000 * 10**18; // Maximum 1M tokens\n    \n    // Reward calculation\n    uint256 public rewardRate = 1000;            // Base reward rate (0.1% per day)\n    uint256 public constant REWARD_RATE_DECIMALS = 10000; // 10000 = 100%\n    uint256 public lastUpdateTime;               // Last time rewards were calculated\n    uint256 public rewardPerTokenStored;         // Accumulated rewards per token\n    \n    // Staking tiers with different reward multipliers\n    struct StakingTier {\n        uint256 duration;        // Lock period in seconds\n        uint256 multiplier;      // Reward multiplier (10000 = 1x)\n        bool active;            // Whether this tier is active\n    }\n    \n    mapping(uint256 => StakingTier) public stakingTiers;\n    uint256 public tierCount;\n    \n    // User staking information\n    struct StakingInfo {\n        uint256 amount;         // Amount staked\n        uint256 tier;           // Staking tier\n        uint256 startTime;      // When staking started\n        uint256 lastClaimTime;  // Last time rewards were claimed\n        uint256 rewardDebt;     // Reward debt for accurate calculation\n        bool active;            // Whether the stake is active\n    }\n    \n    mapping(address => StakingInfo[]) public userStakes;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    \n    // ============ EVENTS ============\n    \n    event Staked(address indexed user, uint256 amount, uint256 tier, uint256 stakeId);\n    event Unstaked(address indexed user, uint256 amount, uint256 stakeId);\n    event RewardClaimed(address indexed user, uint256 amount);\n    event RewardRateUpdated(uint256 newRate);\n    event StakingTierAdded(uint256 tierId, uint256 duration, uint256 multiplier);\n    event StakingTierUpdated(uint256 tierId, bool active);\n    event EmergencyWithdraw(address indexed user, uint256 amount);\n    \n    // ============ CONSTRUCTOR ============\n    \n    /**\n     * @dev Constructor to initialize the staking contract\n     * @param _stakingToken Address of the token to be staked\n     * @param _rewardToken Address of the reward token\n     */\n    constructor(address _stakingToken, address _rewardToken) Ownable(msg.sender) {\n        require(_stakingToken != address(0), \"Invalid staking token address\");\n        require(_rewardToken != address(0), \"Invalid reward token address\");\n        \n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        lastUpdateTime = block.timestamp;\n        \n        // Initialize default staking tiers\n        _addStakingTier(30 days, 10000);      // 30 days, 1x multiplier\n        _addStakingTier(90 days, 15000);      // 90 days, 1.5x multiplier\n        _addStakingTier(180 days, 20000);     // 180 days, 2x multiplier\n        _addStakingTier(365 days, 30000);     // 365 days, 3x multiplier\n    }\n    \n    // ============ MODIFIERS ============\n    \n    /**\n     * @dev Modifier to update reward calculations\n     */\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        \n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    // ============ VIEW FUNCTIONS ============\n    \n    /**\n     * @dev Returns the last time rewards were applicable\n     * @return The last time rewards were calculated\n     */\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp;\n    }\n    \n    /**\n     * @dev Returns the current reward per token\n     * @return The accumulated rewards per token\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked == 0) {\n            return rewardPerTokenStored;\n        }\n        \n        return rewardPerTokenStored + \n               ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) / \n               (totalStaked * 86400); // 86400 seconds in a day\n    }\n    \n    /**\n     * @dev Returns the earned rewards for an account\n     * @param account The account to check\n     * @return The amount of rewards earned\n     */\n    function earned(address account) public view returns (uint256) {\n        return ((_getUserTotalStaked(account) * (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18) + rewards[account];\n    }\n    \n    /**\n     * @dev Returns the total amount staked by a user\n     * @param user The user address\n     * @return The total staked amount\n     */\n    function getUserTotalStaked(address user) external view returns (uint256) {\n        return _getUserTotalStaked(user);\n    }\n    \n    /**\n     * @dev Returns the number of active stakes for a user\n     * @param user The user address\n     * @return The number of active stakes\n     */\n    function getUserStakeCount(address user) external view returns (uint256) {\n        return userStakes[user].length;\n    }\n    \n    /**\n     * @dev Returns staking information for a specific stake\n     * @param user The user address\n     * @param stakeId The stake ID\n     * @return The staking information\n     */\n    function getUserStake(address user, uint256 stakeId) external view returns (StakingInfo memory) {\n        require(stakeId < userStakes[user].length, \"Invalid stake ID\");\n        return userStakes[user][stakeId];\n    }\n    \n    /**\n     * @dev Returns whether a stake can be unstaked (lock period completed)\n     * @param user The user address\n     * @param stakeId The stake ID\n     * @return True if the stake can be unstaked\n     */\n    function canUnstake(address user, uint256 stakeId) external view returns (bool) {\n        require(stakeId < userStakes[user].length, \"Invalid stake ID\");\n        StakingInfo memory userStake = userStakes[user][stakeId];\n        \n        if (!userStake.active) return false;\n        \n        uint256 lockEndTime = userStake.startTime + stakingTiers[userStake.tier].duration;\n        return block.timestamp >= lockEndTime;\n    }\n    \n    // ============ STAKING FUNCTIONS ============\n    \n    /**\n     * @dev Stakes tokens for a specific tier\n     * @param amount The amount of tokens to stake\n     * @param tier The staking tier\n     */\n    function stake(uint256 amount, uint256 tier) external whenNotPaused nonReentrant updateReward(msg.sender) {\n        require(amount >= MIN_STAKE_AMOUNT, \"Amount below minimum stake\");\n        require(amount <= MAX_STAKE_AMOUNT, \"Amount exceeds maximum stake\");\n        require(tier < tierCount, \"Invalid staking tier\");\n        require(stakingTiers[tier].active, \"Staking tier not active\");\n        require(stakingToken.balanceOf(msg.sender) >= amount, \"Insufficient token balance\");\n        require(stakingToken.allowance(msg.sender, address(this)) >= amount, \"Insufficient allowance\");\n        \n        // Transfer tokens from user to contract\n        stakingToken.transferFrom(msg.sender, address(this), amount);\n        \n        // Create new stake\n        StakingInfo memory newStake = StakingInfo({\n            amount: amount,\n            tier: tier,\n            startTime: block.timestamp,\n            lastClaimTime: block.timestamp,\n            rewardDebt: 0,\n            active: true\n        });\n        \n        userStakes[msg.sender].push(newStake);\n        totalStaked += amount;\n        \n        emit Staked(msg.sender, amount, tier, userStakes[msg.sender].length - 1);\n    }\n    \n    /**\n     * @dev Unstakes tokens from a specific stake\n     * @param stakeId The ID of the stake to unstake\n     */\n    function unstake(uint256 stakeId) external whenNotPaused nonReentrant updateReward(msg.sender) {\n        require(stakeId < userStakes[msg.sender].length, \"Invalid stake ID\");\n        StakingInfo storage userStake = userStakes[msg.sender][stakeId];\n        require(userStake.active, \"Stake not active\");\n        \n        // Check if lock period has ended\n        uint256 lockEndTime = userStake.startTime + stakingTiers[userStake.tier].duration;\n        require(block.timestamp >= lockEndTime, \"Stake still locked\");\n        \n        uint256 stakeAmount = userStake.amount;\n        userStake.active = false;\n        totalStaked -= stakeAmount;\n        \n        // Transfer tokens back to user\n        stakingToken.transfer(msg.sender, stakeAmount);\n        \n        emit Unstaked(msg.sender, stakeAmount, stakeId);\n    }\n    \n    /**\n     * @dev Claims accumulated rewards\n     */\n    function claimRewards() external whenNotPaused nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        require(reward > 0, \"No rewards to claim\");\n        require(rewardToken.balanceOf(address(this)) >= reward, \"Insufficient reward token balance\");\n        \n        rewards[msg.sender] = 0;\n        totalRewardsDistributed += reward;\n        \n        rewardToken.transfer(msg.sender, reward);\n        \n        emit RewardClaimed(msg.sender, reward);\n    }\n    \n    /**\n     * @dev Emergency unstake (with penalty) - only for owner\n     * @param user The user address\n     * @param stakeId The stake ID\n     */\n    function emergencyUnstake(address user, uint256 stakeId) external onlyOwner {\n        require(stakeId < userStakes[user].length, \"Invalid stake ID\");\n        StakingInfo storage userStake = userStakes[user][stakeId];\n        require(userStake.active, \"Stake not active\");\n        \n        uint256 stakeAmount = userStake.amount;\n        userStake.active = false;\n        totalStaked -= stakeAmount;\n        \n        // Apply 50% penalty for emergency unstake\n        uint256 penaltyAmount = stakeAmount / 2;\n        uint256 returnAmount = stakeAmount - penaltyAmount;\n        \n        // Transfer remaining tokens to user\n        stakingToken.transfer(user, returnAmount);\n        \n        emit EmergencyWithdraw(user, returnAmount);\n    }\n    \n    // ============ ADMIN FUNCTIONS ============\n    \n    /**\n     * @dev Adds a new staking tier\n     * @param duration The lock duration in seconds\n     * @param multiplier The reward multiplier (10000 = 1x)\n     */\n    function addStakingTier(uint256 duration, uint256 multiplier) external onlyOwner {\n        _addStakingTier(duration, multiplier);\n    }\n    \n    /**\n     * @dev Updates a staking tier's active status\n     * @param tierId The tier ID\n     * @param active Whether the tier is active\n     */\n    function updateStakingTier(uint256 tierId, bool active) external onlyOwner {\n        require(tierId < tierCount, \"Invalid tier ID\");\n        stakingTiers[tierId].active = active;\n        emit StakingTierUpdated(tierId, active);\n    }\n    \n    /**\n     * @dev Updates the reward rate\n     * @param newRate The new reward rate\n     */\n    function updateRewardRate(uint256 newRate) external onlyOwner updateReward(address(0)) {\n        require(newRate > 0, \"Invalid reward rate\");\n        rewardRate = newRate;\n        emit RewardRateUpdated(newRate);\n    }\n    \n    /**\n     * @dev Deposits reward tokens into the contract\n     * @param amount The amount of reward tokens to deposit\n     */\n    function depositRewards(uint256 amount) external onlyOwner {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(rewardToken.balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n        require(rewardToken.allowance(msg.sender, address(this)) >= amount, \"Insufficient allowance\");\n        \n        rewardToken.transferFrom(msg.sender, address(this), amount);\n    }\n    \n    /**\n     * @dev Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n    \n    /**\n     * @dev Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n    \n    /**\n     * @dev Emergency function to withdraw stuck tokens\n     * @param token The token address\n     * @param amount The amount to withdraw\n     */\n    function emergencyWithdrawToken(address token, uint256 amount) external onlyOwner {\n        require(token != address(stakingToken), \"Cannot withdraw staking token\");\n        IERC20(token).transfer(owner(), amount);\n    }\n    \n    // ============ INTERNAL FUNCTIONS ============\n    \n    /**\n     * @dev Internal function to add a staking tier\n     * @param duration The lock duration in seconds\n     * @param multiplier The reward multiplier\n     */\n    function _addStakingTier(uint256 duration, uint256 multiplier) internal {\n        require(duration > 0, \"Invalid duration\");\n        require(multiplier > 0, \"Invalid multiplier\");\n        \n        stakingTiers[tierCount] = StakingTier({\n            duration: duration,\n            multiplier: multiplier,\n            active: true\n        });\n        \n        emit StakingTierAdded(tierCount, duration, multiplier);\n        tierCount++;\n    }\n    \n    /**\n     * @dev Internal function to get user's total staked amount\n     * @param user The user address\n     * @return The total staked amount\n     */\n    function _getUserTotalStaked(address user) internal view returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < userStakes[user].length; i++) {\n            if (userStakes[user][i].active) {\n                total += userStakes[user][i].amount;\n            }\n        }\n        return total;\n    }\n}\n"
      }
    }
  }
}